#### 顺序表



[顺序表]()，全名顺序存储结构，是[线性表](http://data.biancheng.net/view/157.html)的一种。



顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块`足够大小的物理空间`，然后将数据`依次存储起来`，存储时做到数据元素之间`不留一丝缝隙`。



使用顺序表存储集合 `{1,2,3,4,5}`，数据最终的存储状态如[图](http://data.biancheng.net/view/200.html) 1 所示：

![](http://data.biancheng.net/uploads/allimg/181121/2-1Q121202555F0.gif)



将“具有 '一对一' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是[顺序存储结构]()。



通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同[数组](http://data.biancheng.net/view/181.html)非常接近。其实，顺序表存储数据使用的就是数组。



## 顺序表的初始化

使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：

1. 顺序表申请的存储容量；
2. 顺序表的长度，也就是表中存储数据元素的个数；

正常状态下，顺序表申请的存储容量要大于顺序表的长度。



我们需要自定义顺序表



```
typedef struct Table{
    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”
    int length;//记录当前顺序表的长度
    int size;//记录顺序表分配的存储容量
}table;
```

注意，head 是我们声明的一个未初始化的`动态数组`，不要只把它看做是普通的指针。



接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：

- 给 head 动态数据申请足够大小的物理空间；
- 给 size 和 length 赋初值；

```
#define Size 5 //对Size进行宏定义，表示顺序表申请空间的大小

table initTable(){
    table t;
    t.head=(int*)malloc(Size*sizeof(int));//构造一个空的顺序表，动态申请存储空间
    if (!t.head) //如果申请失败，作出提示并直接退出程序
    {
        printf("初始化失败");
        exit(0);
    }
    t.length=0;//空表的长度初始化为0
    t.size=Size;//空表的初始存储空间为Size
    return t;
}
```

我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。

与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。



通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素

```
    table t=initTable();
    //向顺序表中添加元素
    for (int i=1; i<=Size; i++) {
        t.head[i-1]=i;
        t.length++;
    }
```




